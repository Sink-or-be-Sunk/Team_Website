<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, available online at https://engineering.purdue.edu/ece477/Course/Policies/policies.html

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<!-- <base href="https://engineering.purdue.edu/477grp8/" /> -->
<base href="https://sink-or-be-sunk.github.io/Team_Website/" />

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="img/banner.png"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		<div id="content">
            <h2>Progress Report for Garrett Brillhart</h2>
            
            <h4>Week 1:</h4>
            <b>Date:</b> 9/1/2021<br>
            <b>Total hours:</b> 5<br>
            <b>Description of design efforts:</b><br>
		Garrett worked with his team on creating a final design proposal. Garrett specifically worked on defining tasking and responsibilities for each team members in their respective positions and worked with Mitch on creating a rough estimated budget for the project. The whole team worked on and contributed to creating Sink or be Sunk's PSSCs. This work was done through internet research and collaboration with the team. Garrett learned that there is much more that goes into a parts list than simply a microcontroller and PCB. Things such as hinge assemblies, shipping, and plastic case assemblies must be considered. The result is that the team has clearly defined roles, an estimated cost to further refine, and PSSCs that the team will be able to get feedback on from course staff. The next steps to be taken will be to further refine the Sink or be Sunk into specific criteria and to finalize ideas on the design and behavior of the project.
		</br>
            <br>

            <h4>Week 2:</h4>
            <b>Date:</b> 9/3/2021<br>
            <b>Total hours:</b> 10 <br>
            <b>Description of design efforts:</b><br>
        	Garrett worked on formalizing the functional specification of Sink or be Sunk this week. He defined and completed the functional description to establish the specifics of what the project will exactly behave and perform. Garrett also developed the usage case for the system as well as define several constraints including Computational, Thermal/Power, and Mechanical Constraints. This was done through internet research and decisions made by the team. The resulting work allows Garrett and the rest of the team to begin working on more technical aspects of design and software now that the functional description of the project is clear. Garrett learned that many things go into consideration when developing a project and it is not limited to simply coding and designing in a box. The next steps will be to specify and finalize more technical details of the software and hardware as development begins. </br> </br>

<p><img src="Team/progress/img/Week_2_progress_report.jpg" width="400" height="600"></img></p>

	Garrett also began experimenting with an ESP32-WROVER-B development board. This includes installing the necessary prerequisites, eclipse IDE, creating a basic test rig on a breadboard, and exporting code from other team members onto his local machine to work with. The work included ensuring that Mitch's work to connect to a sever websocket and pull up the Sink or be Sunk webpage could be successfully replicated and utilized. Once the connection was established, Garrett then began experimenting with the ESP32 to perform basic functions, such as I/O and blinking LEDs. This was all performed on a local machine utilizing ESP32 software and the Eclipse development program on the aforementioned simple test rig (also pictured above). The result was that Garrett was able to successfully implement code from another team member and is able to perform basic functions with an ESP32 dev board. Garrett learned about programming for an ESP32 compared to a microncontroller he was familiar with (like the STM32). He also learned how to manage Git in a multi-developer project to ensure continous progress and cohesion. Garrett will next dive into learning to use the WiFi connection aspect of the ESP32 and attempt to send packets to the websocket server which will be an important part of the overall function of the project. Additionally, he will work on the test rig to include keypad and a small array of LEDs and attempt to include some basic functionality to them.

	</br>
            <h4>Week 3:</h4>
            <b>Date:</b> 9/10/2021<br>
            <b>Total hours:</b> 15 <br>
            <b>Description of design efforts:</b><br>

	I worked on continuing experimentation with the ESP32 development board and debugging both the development environment and board itself. What I believed to be successful implementation of Mitch's websocket code through the Eclipse IDE turned out to be untrue. While Eclipse had successfully built and flashed the code, the websocket data that I thought was working as intended, was just the BLE provisioning attempting to work. After some attempts at managing the libraries and necessary infrastructure in Eclipse, I decided to instead begin to work through VSCode and the ESP-IDF extenstions built into it. This also ensures that Mitch, myself, and the rest of the team share the same platform for ease of porting. <br>
	VSCode also raised some time-consuming issues, requiring use of the master/development branch for utilization of Mitch's code and Windows having COM port driver issues. Eventually, the websocket code was successfully implemented, flashed, and ran on the ESP32, much to my delight. 
	After finally perfecting the development environment, I began experimenting more with LEDs and a simple keypad button detection. Three LEDs (Red, Yellow, Green) now indicate the websocket connection status, seen on the test rig picture below. The red LED indicates the device is loading, booting, or otherwise in an error. The yellow LED indicates the websocket server is provisioning, and is awaiting user input from their mobile phone through the ESP app. The green LED indicates a successful connection to the websocket.
	The keypad code led to some interesting developments and part of the code can be seen in the code snippet below. The process of scanning and listening through the keypad is to my knowledge implemented correctly and returns most of the buttons pressed. Through trial and error, I discovered that ports 16, 0, and 17 appear to be blown out on the development board, thus allowing only columns 2, 4 and rows 1-3 to work as intended. I would like to use another development board to double-check that it is a hardware issue and not in my code, but running some test code to check for voltages proved fairly convincing. 

<p><img src="Team/progress/img/test_rig_wk3.jpg" width="400" height="600"></img>
<img src="Team/progress/img/Code_Snippet_Wk3.PNG" width="400" height="600"></img></p>
	The results of this week's work allowed me to truly setup a way to develop the software and alerted me to possible dev board issues that need immediate addressing. Developing code on a faulty board could have had some far-reaching consequences, had I not caught it this early.
	I learned much more about ESP32 programming, and instead of directly copying code from the internet (only for experimentation purposes of course), I believe I can start creating necessary software for a number of the peripherals. I also learned how to implement the ESP-IDF from VSCode, so that instead of taking hours it would take maybe 30 minutes to install fully and correctly. 
	The next steps to be taken will be to ensure that the development board I possess from the ECE shop is faulty and secure a working development board. Once that is done, I will work on creating a more functional keypad decipherer that is more focused towards the project (i.e. looking for attack coordinates, starting a game, etc.). Also, I want to work with SPI protocol to an LCD interface and display some meaningful data to both refresh myself and lay a foundation for LCD implementation in the project.

	</br>
            <h4>Week 4:</h4>
            <b>Date:</b> 9/17/2021<br>
            <b>Total hours:</b> 10 <br>
            <b>Description of design efforts:</b><br>
	I worked on researching and attempting to implement SPI utilizing the ESP32 devboard to communicate with an old ECE 362 OLED display.
	Also, I confirmed that the development board I had used to develop a keypad scanning algorithm was faulty. I flashed another board and the code worked exactly as designed, so the keypad fully works now. 
The majority of my time was spent attempting to get the SPI interface to a workable framework. Unfortunately, the OLED I had from ECE 362 is also blown out, as it doesn't light up at all when powered, so was unable to truly test my code. 
Plenty of work was done however, attempting to refresh myself on SPI and building a framework to do so with an ESP32. The ESP-IDF has quite a lot of information and references to work from. However, many of the resources attempt to make it easier by providing libraries and code examples to work from. This is incredibly useful IF you are comfortable with the materials the libraries provide. For me, the abstractness and handlers that these libraries offer make it incredibly confusing for someone like me attempting to learn it for the first time. 
With ECE 362, much of the difficulty with SPI came from identifying ports and registers to change and managing the specific characteristics of the display to send the data through SPI.
With the ESP32, much of this is done behind the scenes of the function calls, the issues arise from building the structures and knowing how these functions all work together in order to use them properly.
Many of the examples I could find to reference off of, were created from what I assume are mega-geniuses. I spent the vast majority of my time working backward from convulted and intricate code to try and build a framework that was simple and applicable to my usage case of the OLED. The two figures below are code snippets from this framework that I built referencing ExpressIfs code examples. To be honest, since I cannot test it with a broken OLED, I am not sure if it works or not. </br>
Regardless of the result of my work, the knowledge I gained was time well spent. Through the sea of information, I found many key resources that will be invaluable to both the SPI connection to the OLED and other peripherals. I learned much about utilizing resources provided and got experience attempting to implement them. Ideally, the framework I built will either work or be close to a working state, and I will have then prototyped our display for the project with applicable code to the final design. The next steps I will take is to get a working OLED board and work with TA Fangda to successfully implement the SPI. This could take a wide range of time, depending on my programming. If time, I would like to work on developing code that can do the ship detection. Building a simple test rig with some multiplexers and seeing if I can identify where I place a ship. Also, once the OLED works, I can begin developing the frontend of the user experience and preparing messages such as showing the coordinates as the user types them in, you are playing against xxxx, etc.



<p><img src="Team/progress/img/Code_SPI_1.PNG" width="425" height="700"></img>
<img src="Team/progress/img/Code_SPI_2.PNG" width="425" height="700"></img></p>

	</br>
            <h4>Week 5:</h4>
            <b>Date:</b> 9/24/2021<br>
            <b>Total hours:</b> 15 <br>
            <b>Description of design efforts:</b><br>
	I worked on implementing SPI communication to an OLED board to display relevant game information and worked on conglomerating the display code and the keypad code to work together.
	The main part of the workload was debugging and exploring documentation related to SPI communication and the SOC1602A OLED board. My original framework had several bugs, including accidentally flipping the MOSI and MISO GPIO pins within the microcontroller code. 
	The majority of the debugging was done using an Analog Discovery 2 with digital I/O pins in order to see what signals were coming from the microcontroller and why they weren't displaying to the OLED correctly.
	The MISO/MOSI flip was discovered by looking at the DATA line and seeing that the ESP32 had it constantly set to logic high.
	However, the display still refused to output the correct characters on the OLED and instead showed flickering, random symbols. I could see the correct data using the AD2, with the correct characters in ASCII being outputted.
	I looked deeper into the ESP32 SPI driver and OLED documentation to find the issue was with the 2 command bits that preface a byte. "00" was supposed to preface the command and "10" prefaced data to write. 
	Upon applying these changes and debugging, the SPI communication worked perfectly, as you can see in the below image.

</br>
<img src="Team/progress/img/Wk5_Display2.jpg" width="800" height="400" align="middle" />
</br>
	I also combined the keypad code I developed and the newly created display code to begin making relevant functionality for the battleship game. 
	The combined code allows me to see the physical key press data rather than just monitoring the microcontroller on my computer using printf. As you can see below, the OLED now displays whichever key button was pressed by the user, an important function the project will need to display useful information and entering coordinates as shown below.
	This also required an update to my test rig in order to accommodate both the display and the keypad GPIO pins to connect them in a single microcontroller orientation.
</br>
<img src="Team/progress/img/Wk5_Display1.jpg" width="400" height="600" align="middle" />
</br>
	The result of this week's work is that a viable SPI framework has been developed and I now have a centralized C file that I can prototype off of, rather than split off in multiple projects. The SPI display and keypad scanning work is essentially done, only difference being that the display ordered for the project may have slightly different commands and format, which is easily adjusted. I learned more about SPI and how character displays work and feel confident in being able to adjust the code to the projects specific display. I also learned that sometimes the way to debug is to use external sources, such as the AD2, to physically look at and explore the peripheral outputs.
Next week, I would like to begin developing a prototype boat scanning test rig, now that the team has finalized how we plan to accomplish this. By creating a multiplexed array and checking for shorts, I should be able to develop applicable code for the input of boats by the user.


</br>
            <h4>Week 6:</h4>
            <b>Date:</b> 10/1/2021<br>
            <b>Total hours:</b> 10 <br>
            <b>Description of design efforts:</b><br>
			For Week 6, I worked on prototyping hardware and developing the software for the boat detection. To detect a boat, a 3 to 8 multiplexer selects between 8 other multiplexers,
			which are then receiving the input of 8 "slots" each, for a total of 64 inputs. The microcontroller cycles through the column select lines, and then the row select lines, 
			and looks for a "slot" that has been pulled high. Once a high input logic has been detected, by checking the row and column it occurred on, the microcontroller can identify the 
			position of the placement. As you can see in the test rig below, I only had 6 multiplexers total and enough resistors to pull up 16 inputs, so the microcontroller only cycles 
			through 16 currently, but the concept is the same. I then had the row and column be identified and sent to the display to prove it was identified correctly. If I were to 
			improve the test rig, I would need enough resistors for all of the multiplexers but am confident that the code works as intended through my testing. As a result, the boat
			detection has been prototyped to have real value and should work come implementation time. I learned how the specific boat detection circuit works, as it took me building
			all 5 multiplexers in and debugging to realize I needed pull-up resistors for every input because the mux cannot sink that amount of current in a short. The next steps for me 
			will be acquiring more resistors to hopefully finish the rig, and to work on software to begin identifying where a boat of length would be placed. Essentially, scanning the 
			rows and columns once a short has been detected to find another short, and find each slot that the boat covers. I also want to use a LUT to discard boats that have already been 
			placed.

</br>
<img src="Team/progress/img/Wk6_Test_Rig.jpg" width="400" height="600" align="middle" />
</br>
		<h4>Week 7:</h4>
		<b>Date:</b> 10/8/2021<br>
		<b>Total hours:</b> 8 <br>
		<b>Description of design efforts:</b><br>
		For Week 7, I worked on developing the software to have more functionality regarding boat placement. Essentially, I worked on designing software that looks for 2 shorts, and 
		then looks through the rows and columns to determine the spaces in between. This required quite a few changes to the original short detection, as I had to work with malloc'd
		array of Coordinates, and add the new Boat Coordinates to that array. That array is global, which I wasn't originally planning on having, but I'm trying to maintain flexibility
		in my software design until the code is conglomerated into a single build. The code also now checks to see if the slots are being used, and "skips" over any actions on them
		if a boat has been previously detected, done using the global array of boat slots. To optimize a bit, this check is only done if a short is detected, so at most it can only happen
		15 times in a 64 slot scan (All other boats besides the size 2 boat is placed). The test rig was updated to include a 3rd MUX with resistors, just so I had more room to test, as 
		shown below.

		</br>
		<img src="Team/progress/img/Wk7_Test_Rig.jpg" width="400" height="600" align="middle" />
		</br>
		The result is that the boat scanning software is largely done. The only changes I can imagine would be necessary is if we want to identify individual boats rather than a list
		of all spaces they exist on and adapting it to the final code. Both could be easily done in 30 minutes. I didn't learn too much, mostly just had to refresh myself with malloc 
		in C. I also had to brainstorm a few ways to keep the code fast, and even though the ESP32 is powerful, I really do not want to bog it down at all with unoptimized code That
		could take awhile if it was constantly working in memory and scanning. The next steps I want to take is beginning to work on the DAC and speaker. This may take a few weeks as 
		analog is notoriously tricky, but I'd like to get it to the point where I can play a simple audio file.
	</br>
		<h4>Week 9:</h4>
		<b>Date:</b> 10/22/2021<br>
		<b>Total hours:</b> 12 <br>
		<b>Description of design efforts:</b><br>
		For Week 9, I revamped and finished the boat detection some more and began looking into using the DAC for playing audio files. Upon further testing, I realized that boat detection
		software I had already developed was buggy and unreliable, especially with multiple boats plugged in. Originally the boat could have issues when placed along the same row or column
		and overall was not detecting correctly on occasion. My solution was to revamp the way the software worked, mainly in the data structures and the logic. Instead of a dynamically allocated array,
		a new data structure containing a fixed length array and a length (of what part of the array has been filled) contains all the boat coordinates. It makes it easier to work with, 
		more efficient on the microcontroller, and is overall "cleaner". The logic was improved in the way that looked for the "in-between" coordinates. The software first determines the minimum
		and maximum row/column between the two shorts, and simply adds the minimum to maximum as it goes. That way, the entire boat is added to the global data structure in one loop.
		In doing so, I fixed the bugs and reliability issues that had plagued it. Also, determining which boat has been placed is easy. Simply check the length of the global structure before,
		call the boat scan, and compare the length again after to determine the length of the boat that has been added and therefore uniquely identify the boat.

		</br>
		<img src="Team/progress/img/Week9_Test_Rig.jpg" width="400" height="600" align="middle" />
		</br>
		I dove a bit into audio playing as well. Unfortunately, the only documentation I could find in playing music was utilizing Arduino boards or Arduino software. Because of this, I'll
		most likely have to build this from scratch, using generic DAC-to-audio guidelines I can find on the internet and adapt them to ESP-IDF framework. Might take some time. Our team is 
		also debating using a TTRS adapter for aux cord audio or continue to attempt to make it play from the speaker. The speaker is desireable, but several issues exist as the speaker is 
		too quiet without massive power, too centered around higher pitch frequencies, and is having weird "railing" effects from attempting to play a sinusoidal. Regardless, it doesn't change
		my software development. 
	</br>
		The results of this weeks work is that boat detection is 100% complete and ready to be inserted into the general gameflow. If we want to do boat confirm, we simply ask the user to
		place their boat, confirm the location, and then start the boat scan. The speaker work allowed the team to consider alternatives to our current speaker model and showed me the amount of
		time creating an audio player without using Arduino may take. I learned how tricky analog can be, understood the workload from playing audio files, and learned to revise and rework code 
		I had thought was fine before rigorous testing. The next steps to be taken will be develop audio for the game. A function where I can enter in a frequency and time and have the DAC
		output that signal as a sine wave would be ideal. Probably won't get to playing an audio file quite yet, but at the very least could create jingle from playing different notes.

		<h4>Week 10:</h4>
		<b>Date:</b> 10/22/2021<br>
		<b>Total hours:</b> 2 <br>
		<b>Description of design efforts:</b><br>
		Week 10 was an extremely busy week for me, with 3 exams and two projects in other classes. As a result, I managed to work just a little bit on the audio and speaker aspect of the project.
		As seen in the picture below, a circuit from ECE 362 is utilized with a TTRS adapter. As the audio system is not a PSSC, it is no big deal to switch to a headphone jack system. I pondered
		some use cases and looked through old ECE 362 code developed to play audio, and I believe it is reasonable to get decent audio output through the TTRS adapter without too much difficulty.
		Much can be done to improve the audio quality, such as blending and fading, but that is not a large concern. From this, I can begin working and testing audio output from the DAC to begin
		building a function that can play a sound file (most likely a MIDI file). For next week, I would like to be able to get some audio output, with minimum of different sine waves at different 
		frequencies. Not too much learned this week, as much of the learning curve will come next week when I have time to dedicate to the project.

		</br>
		<img src="Team/progress/img/Test_Rig_Wk10.jpg" width="400" height="600" align="middle" />
		</br>
	</br>
	
		<h4>Week 11:</h4>
		<b>Date:</b> 11/5/2021<br>
		<b>Total hours:</b> 10 <br>
		<b>Description of design efforts:</b><br>
		In Week 11, I continued development on playing audio and with the arrival of our PCBs, began soldering components onto our Grid PCBs. I learned how to solder an IC
		(the multiplexer) by hand, which was a lot of fun. I also learned the process for reflow soldering, by using our solder mask, placing components onto the PCB, and placing it into the oven.
		It gave a lot of satisfaction to see the one board that I had soldered completely come out of the oven and then tested successfully with our team. Audio wise on the circuit developed last week, the image directly below
		depicts the main progress I made, using a built in cosine wav generator in the DAC to output a wave of increasing frequency and then back down. The example shown goes from 130 Hz to 3000Hz. 
		With this, I can play simple jingles or tunes by changing the frequency output to specific notes and setting the duration. Although rudimentary, it could serve as a audio cue for game events
		by playing specific tunes that I would have to hardcode.
		</br>
		<img src="Team/progress/img/Audio_Wave_Cosine.png" width="800" height="400" align="middle" />
		<img src="Team/progress/img/Audio_Wave_Sine.png" width="800" height="400" align="middle" />
		</br>
		The image directly above depicts what I am working on, by precalculating sine values and directly setting the voltage of the DAC. This format gives me much more control, with the ability
		to add waves, notes, and essentially sounds together to get complex audio. The flat line in between each period is a bug I have yet to find and mitigate, which I'll likely have to fix with DMA
		and/or timer interrupts. Once I can make these complex audio waves, I can then begin to work on interpreting audio files to play. The fixing of the bug shouldn't be too much work, but from what 
		I've learned, the file interpretation may take some time. Regardless, the audio is not a PSSC and isn't time sensitive as we build, test, and debug our assembly so it is not a huge priority. But with
		the remaining time, it should be feasible to output audio that will enhance the user experience. I learned much about analog and audio waves, and how finicky they can be in software. I also learned
		through experience how to solder and reflow solder, which is a great skill to have as our boards are built. Next week I'll work on getting rid of that flat line on the manual sine wave and begin working
		on interpreting audio files.
	</br>

		<h4>Week 12:</h4>
		<b>Date:</b> 11/12/2021<br>
		<b>Total hours:</b> 10 <br>
		<b>Description of design efforts:</b><br>
		Unsurprisingly, this week's work on creating a smooth sine wave utilizing a timer interrupt and creating a framework to add together signals to create complex audio wave was much
		more difficult than I had intended. I did quite a bit of research on different audio wave formats and mostly become more confused. Utilizing the midi.c file from ECE 362, I think
		I may be able to interpret the midi file and make some actionable audio using the ESP's DAC. Unfortunately, a key part of that is utilizing a timer to cause interrupts and update the sine wave.
		Making a timer to hit the tick rate of default midi files (about 96 Hz) should be straightforward, yet I've had nothing but issues. As shown below, I created a separate file specifically
		for audio playing and attempted to initialize the timer with these values. I wrote an interrupt service routine for the timer that just advances to the next update on the sine wave. Should output
		a simple sine wave with the 96 Hz wave, not really worrying about smoothness, just trying to get functionality. However, I could not get any meaningful output from it, as it just
		hovers around the 1.65V mark with a little voltage spike every once in awhile. Even trying to output a simple square wave was to no avail, and the output just remained flat. With
		debugging attempts, it seems as though the ISR is never called. 
		</br>
		<img src="Team/progress/img/Garrett_Prog_Report_Audio.png" width="800" height="400" align="middle" />
		</br>
		I tried a whole bunch of things, just to get simple changes from a timer. I'm still not sure of the reasoning of why I can't get the timer to work, but I have a few ideas. The ESP32 
		timers have some alarm configuration on it, and the documentation is extremely obtuse about what it actually does. It could also be with the FreeRTOS system and how functions are called
		between each other. Yet, I'm following the steps laid out by the ESP-IDF documentation exactly in setting up my timer and it's just weird that I cannot get a single periodic interrupt out 
		of it. I even tried using one of the high resolution timers which seemed less software heavy to use, yet I still couldn't get a signal out.
	</br>
	</br>
		Resulting from all of this, I recognize that I will need some assistance in managing timers and audio with the ESP. It may be a simple fix for the timer (hopefully), but even the audio 
		file interpretation and playing is a monster task in itself. I learned that ESP-IDF documentation can be helpful, but they do not explain many concepts and functions that is not obvious,
		at least to me. I did learn quite a bit about audio, and believe I have a decent approach to how I can interpret MIDI files and begin to play them. Obviously, I learned a lot about timers
		but it seems I still have much to go. For the next steps, I'm going to continue to try and fix my timer and begin more audio framework, and seek assistance with some parts of the code 
		as I believe I am conceptually missing a good chunk. Also, a good amount of my focus will be in constructing our actual gameboards as the semester winds down and laying out our PCBs is far
		more important than getting the audio to work.
	</br>

	<h4>Week 13:</h4>
	<b>Date:</b> 11/19/2021<br>
	<b>Total hours:</b> 20 <br>
	<b>Description of design efforts:</b><br>
		This week, I focused on finishing some of the hardware work that just needs to get done. Mainly, the Grid PCBs for all connections and headers. As shown below, I cut, filed, glued, and emplaced 64 of the 2x2 female header pins necessary for detection.
		Myself and another team member (Molly) then proceeded to solder all of them onto 8 boards. Included in this, was finishing other soldering tasks for the bottom Grid PCBs as a few of them 
		were missing multiplexers and connectors. Not a super exciting task, but quite time consuming. I also finished soldering the connectors (all the reflow soldering had already been done) for the 
		top 8 boards, for LED communication and power and ground. The top boards still need testing to ensure the LEDs all respond, but the bottom boards have already been tested and working.
	
	<div style="text-align: center"><img src="Team/progress/img/Garrett_Header_Boards.jpg" width="400" height="600" /></div>
		I also worked on marking the drill holes where we will mount our Grid PCBs. Ended up being more difficult than expected. The bottom PCB's connectors elevate the PCB off the base and cannot lie flat,
		making it difficult for PCBs that need to be exactly spaced correctly so that the boats will fit into the headers. The first attempt, on the bottom left, was to use tape and a male header pin 
		"jig" to try and line everything up correctly. It technically worked, but the simple task of marking the bottom was impossible since it was raised off and the vibration of tapping a nail caused the 
		PCBs to shift. The second attempt was a much better idea (idea from Molly), to simply use the unused PCBs that would lay flat onto it and could be easily marked (bottom-right picture).
		Worked like a charm and now have perfectly lined up drill hole markings. Unfortunately, it turns out that our PCBs are being mounted to the top sheet of acrylic, rather than the bottom of the casing.
		Bit of miscommunication between myself and teammates. The good news is that because the acrylic is clear, I can simply cut it to shape and then re-mark the holes on the acrylic for drilling so re-spacing
		everything isn't necessary and time is not wasted.
	<p><img src="Team/progress/img/Garrett_First_Layout.jpg" width="425" height="700"></img>
	<img src="Team/progress/img/Garrett_Second_Layout.jpg" width="425" height="700"></img></p>
		Resulting from this work, once I get my hands on the acrylic and a bandsaw, I can cut out the acrylic and mount all the completed PCBs onto it. It means that packaging for the project
		will be much closer to being completed. Once the connecting pieces, cables, and placement for the LCD and keypad are made, the project will be almost fully together hardware wise and can be tested
		in a much more rigorous fashion. I learned how much actually goes into packaging, as it is mostly an afterthought, as well as improving my soldering skills tremendously. For the next steps, I would like
		to mount and package everything for the first board. We still have an entire second board to do, but for our PSSCs, getting this done is essential. The audio development is on the back burner for now,
		but I may work on it once the necessary hardware and PSSC tasks are completed.

		<h4>Week 14:</h4>
		<b>Date:</b> 11/28/2021<br>
		<b>Total hours:</b> 7 <br>
		<b>Description of design efforts:</b><br>
			For this fine Thanksgiving week, I worked on more packaging and assisted Molly with adapting our main PCB to interact with keypad and LCD. Shown below, I assembled and mounted all of
			the bottom Grid PCB boards to the acrylic sheet that was cut. The top acrylic needs to be recut so that we don't have the boat holes unnecessarily. Looks pretty good and fit well, with some
			adjustments and filing. Once the top sheet is cut, I can assemble that as well and build the connectors to start linking all the functional blocks together.
		
		<div style="text-align: center"><img src="Team/progress/img/Brillhart_Turkey_Week.jpg" width="600" height="400" /></div>
			Molly and I also worked on debugging and trying to flywire our PCB board to get the correct functionality of both the Keypad and the LCD. Since I had prototyped the Keypad and found many of the nuances
			that go with it (ex. pins are ordered column row rather than row column), it helped a lot for the team for me to get a second pair of eyes on the hardware. The PCB also had a conceptual flaw with the resistors
			on rows rather than columns, and having pull down resistors to perpetually ground them. We managed to identify and work through these issues. Unfortunately, we are still having problems with the keypad
			but it most likely lies somewhere in the software, with pin definitions and/or the input only pins.
	</br>
	</br>
			The result of this is that we are finally putting together major pieces of the assembly together, so once our PCB issues are resolved we can fit them all together easily. More work will need to be done to 
			fit and assemble the other blocks, but we are making headway. With the PCB, the process of debugging and flywiring is ongoing. It is a bit stressful with approaching deadlines but I'm confident
			we will be able to make it work in time. Good progress is being made in pin selection and fixing the hardware for the LCD and keypad, two important blocks. I learned that hardware and flywiring is manageable,
			but can be quite tricky to think about. Diagrams and drawings of pins and labels help tremendously. Next, I will continue to assemble blocks of our board and work with my teammates in debugging our main PCB,
			especially for the keypad and LCD. It is also almost certain that we will abandon making a 2nd board, due to our main PCB difficulties and because the game is playable online against the single board.

			<h4>Week 15:</h4>
			<b>Date:</b> 12/3/2021<br>
			<b>Total hours:</b> 10 <br>
			<b>Description of design efforts:</b><br>
				This week consisted of building the connections for the entirety of the base board. Each grid PCB board needs a connector for power and ground, MUX_OUT, SELA, SELB, SELC, and to 
				be daisy chained to the next Grid PCB with LED_in and LED_out. The picture on the bottom left with yellow wire shows the connectors and assembly made for the LEDs. The picture on the 
				bottom right shows some of the connectors I made and how I assembled them, with stranded 22 gauge wire and using a wiring diagram made by Mitch for me. This is straightforward work, but is
				quite time-consuming and detail oriented. I originally designed a solid amount of the connectors using the hand tool that does one at a time, which is extremely slow going. Eventually, I was
				able to get my hands on the connector "hand-gun" which made it much faster. Still, the connections are require crossing the order of wires and managing the placement order. I made sure to double-check
				everything multiple times to ensure that the correct connection was made.
				<p><img src="Team/progress/img/Garrett_LED_Chain.jpg" width="350" height="600"></img>
				<img src="Team/progress/img/Garrett_Full_Shot.jpg" width="425" height="400"></img></p>
					One of the issues we came across, shown below on the picture of PCB below, was that because the connectors do not crimp straight vertically, stacking all the connectors right next to each other
					is impossible as they get into the way of the neighboring connector wires. This is unfortunate as we cannot move the pins on PCB, and either need to make it work somehow or only use
					jumper cables rather than all the connectors I worked hard for. My ideas include stacking female and male headers onto the pins, similar to stadium seating to make it work, although
					the addition of more connectors raises the possibility of a bad connection. It will have to be tested. The result of my work means that connectors are mostly done, with just a few more that need to be
					made and to solve the issue of the stacking. I learned how to use both the hand tool to press wires in and the hand gun tool to do the same but with much more ease. For the next steps,
					the board must be finished and all physical connections and hardware tested and fully assembled. 
			<div style="text-align: center"><img src="Team/progress/img/Garrett_PCB_Connectors.jpg" width="600" height="400" /></div>
			<h4>Week 16:</h4>
			<b>Date:</b> 12/10/2021<br>
			<b>Total hours:</b> 30 <br>
			<b>Description of design efforts:</b><br>
				This week consisted of a lot of group work in finishing, assembling, and packaging our project. There was quite a bit that went into this and a majority of it was a team effort.
				I spraypainted the box black for a sleeker look and made several cardboard iterations of a panel to go over the wiring and main PCB. I drilled many holes and mounted both the top 8 Grid PCBs
				and the main PCB. I also aided in mounting the motor, cut out the hole for the power port and reset switch and mounted them. Myself and the team had to remake a bunch of connectors due to the issue of
				spacing on our main PCB and had to recreate the daisy chain connections for the LEDs. We tore apart jumper cables, soldered them to wires and the red connectors, and used the other end to utilize the vertical
				connector to plug into the main PCB. This was all heat shrunk to make the connectors look nicer and have more durability. The team and I worked to manage all these wires, as it wasn't possible to keep the contained
				to the height of the standoffs without risking breaking them. There was a bunch of other tasks myself and the team did that I'm not remembering, such as labeling the board and aiding in creating the wood paneling
				seen in the final packaging. 
				<p><div style="text-align: center"></div><img src="Team/progress/img/Garrett_Wk16_1.jpg" width="425" height="500"></img>
				<img src="Team/progress/img/Garrett_Wk16_2.jpg" width="400" height="500"></img></p>
					The result of the work done is that we managed to get all of our final PSSCs done and are ready to do the SPARK challenge, with a great looking product and poster. Our board is done, thankfully,
					and is actually really fun to play, use, and looks sleek in the final packaging. I learned that packaging cannot be an afterthought, and even though I started early on it, the connections and managing wires
					really takes an incredible amount of time and a more deliberate action to get it done sooner may have saved myself and the team from being in the lab all week. Next step is to show off our great product to the course staff
					during our final presentation and to the judges at the SPARK show.
				<p><div style="text-align: center"></div><img src="Team/progress/img/Garrett_Wk16_3.jpg" width="425" height="700"></img>
				<img src="Team/progress/img/Garrett_Wk16_4.jpg" width="425" height="700"></img></p>
        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
