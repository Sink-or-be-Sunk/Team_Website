<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, available online at https://engineering.purdue.edu/ece477/Course/Policies/policies.html

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<base href="https://engineering.purdue.edu/477grp8/" />

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="img/banner.png"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		<div id="content">
            <h2>Progress Report for Garrett Brillhart</h2>
            
            <h4>Week 1:</h4>
            <b>Date:</b> 9/1/2021<br>
            <b>Total hours:</b> 5<br>
            <b>Description of design efforts:</b><br>
		Garrett worked with his team on creating a final design proposal. Garrett specifically worked on defining tasking and responsibilities for each team members in their respective positions and worked with Mitch on creating a rough estimated budget for the project. The whole team worked on and contributed to creating Sink or be Sunk's PSSCs. This work was done through internet research and collaboration with the team. Garrett learned that there is much more that goes into a parts list than simply a microcontroller and PCB. Things such as hinge assemblies, shipping, and plastic case assemblies must be considered. The result is that the team has clearly defined roles, an estimated cost to further refine, and PSSCs that the team will be able to get feedback on from course staff. The next steps to be taken will be to further refine the Sink or be Sunk into specific criteria and to finalize ideas on the design and behavior of the project.
		</br>
            <br>

            <h4>Week 2:</h4>
            <b>Date:</b> 9/3/2021<br>
            <b>Total hours:</b> 10 <br>
            <b>Description of design efforts:</b><br>
        	Garrett worked on formalizing the functional specification of Sink or be Sunk this week. He defined and completed the functional description to establish the specifics of what the project will exactly behave and perform. Garrett also developed the usage case for the system as well as define several constraints including Computational, Thermal/Power, and Mechanical Constraints. This was done through internet research and decisions made by the team. The resulting work allows Garrett and the rest of the team to begin working on more technical aspects of design and software now that the functional description of the project is clear. Garrett learned that many things go into consideration when developing a project and it is not limited to simply coding and designing in a box. The next steps will be to specify and finalize more technical details of the software and hardware as development begins. </br> </br>

<p><img src="Team/progress/img/Week_2_progress_report.jpg" width="400" height="600"></img></p>

	Garrett also began experimenting with an ESP32-WROVER-B development board. This includes installing the necessary prerequisites, eclipse IDE, creating a basic test rig on a breadboard, and exporting code from other team members onto his local machine to work with. The work included ensuring that Mitch's work to connect to a sever websocket and pull up the Sink or be Sunk webpage could be successfully replicated and utilized. Once the connection was established, Garrett then began experimenting with the ESP32 to perform basic functions, such as I/O and blinking LEDs. This was all performed on a local machine utilizing ESP32 software and the Eclipse development program on the aforementioned simple test rig (also pictured above). The result was that Garrett was able to successfully implement code from another team member and is able to perform basic functions with an ESP32 dev board. Garrett learned about programming for an ESP32 compared to a microncontroller he was familiar with (like the STM32). He also learned how to manage Git in a multi-developer project to ensure continous progress and cohesion. Garrett will next dive into learning to use the WiFi connection aspect of the ESP32 and attempt to send packets to the websocket server which will be an important part of the overall function of the project. Additionally, he will work on the test rig to include keypad and a small array of LEDs and attempt to include some basic functionality to them.

	</br>
            <h4>Week 3:</h4>
            <b>Date:</b> 9/10/2021<br>
            <b>Total hours:</b> 15 <br>
            <b>Description of design efforts:</b><br>

	I worked on continuing experimentation with the ESP32 development board and debugging both the development environment and board itself. What I believed to be successful implementation of Mitch's websocket code through the Eclipse IDE turned out to be untrue. While Eclipse had successfully built and flashed the code, the websocket data that I thought was working as intended, was just the BLE provisioning attempting to work. After some attempts at managing the libraries and necessary infrastructure in Eclipse, I decided to instead begin to work through VSCode and the ESP-IDF extenstions built into it. This also ensures that Mitch, myself, and the rest of the team share the same platform for ease of porting. <br>
	VSCode also raised some time-consuming issues, requiring use of the master/development branch for utilization of Mitch's code and Windows having COM port driver issues. Eventually, the websocket code was successfully implemented, flashed, and ran on the ESP32, much to my delight. 
	After finally perfecting the development environment, I began experimenting more with LEDs and a simple keypad button detection. Three LEDs (Red, Yellow, Green) now indicate the websocket connection status, seen on the test rig picture below. The red LED indicates the device is loading, booting, or otherwise in an error. The yellow LED indicates the websocket server is provisioning, and is awaiting user input from their mobile phone through the ESP app. The green LED indicates a successful connection to the websocket.
	The keypad code led to some interesting developments and part of the code can be seen in the code snippet below. The process of scanning and listening through the keypad is to my knowledge implemented correctly and returns most of the buttons pressed. Through trial and error, I discovered that ports 16, 0, and 17 appear to be blown out on the development board, thus allowing only columns 2, 4 and rows 1-3 to work as intended. I would like to use another development board to double-check that it is a hardware issue and not in my code, but running some test code to check for voltages proved fairly convincing. 

<p><img src="Team/progress/img/test_rig_wk3.jpg" width="400" height="600"></img>
<img src="Team/progress/img/Code_Snippet_Wk3.PNG" width="400" height="600"></img></p>
	The results of this week's work allowed me to truly setup a way to develop the software and alerted me to possible dev board issues that need immediate addressing. Developing code on a faulty board could have had some far-reaching consequences, had I not caught it this early.
	I learned much more about ESP32 programming, and instead of directly copying code from the internet (only for experimentation purposes of course), I believe I can start creating necessary software for a number of the peripherals. I also learned how to implement the ESP-IDF from VSCode, so that instead of taking hours it would take maybe 30 minutes to install fully and correctly. 
	The next steps to be taken will be to ensure that the development board I possess from the ECE shop is faulty and secure a working development board. Once that is done, I will work on creating a more functional keypad decipherer that is more focused towards the project (i.e. looking for attack coordinates, starting a game, etc.). Also, I want to work with SPI protocol to an LCD interface and display some meaningful data to both refresh myself and lay a foundation for LCD implementation in the project.

	</br>
            <h4>Week 4:</h4>
            <b>Date:</b> 9/17/2021<br>
            <b>Total hours:</b> 10 <br>
            <b>Description of design efforts:</b><br>
	I worked on researching and attempting to implement SPI utilizing the ESP32 devboard to communicate with an old ECE 362 OLED display.
	Also, I confirmed that the development board I had used to develop a keypad scanning algorithm was faulty. I flashed another board and the code worked exactly as designed, so the keypad fully works now. 
The majority of my time was spent attempting to get the SPI interface to a workable framework. Unfortunately, the OLED I had from ECE 362 is also blown out, as it doesn't light up at all when powered, so was unable to truly test my code. 
Plenty of work was done however, attempting to refresh myself on SPI and building a framework to do so with an ESP32. The ESP-IDF has quite a lot of information and references to work from. However, many of the resources attempt to make it easier by providing libraries and code examples to work from. This is incredibly useful IF you are comfortable with the materials the libraries provide. For me, the abstractness and handlers that these libraries offer make it incredibly confusing for someone like me attempting to learn it for the first time. 
With ECE 362, much of the difficulty with SPI came from identifying ports and registers to change and managing the specific characteristics of the display to send the data through SPI.
With the ESP32, much of this is done behind the scenes of the function calls, the issues arise from building the structures and knowing how these functions all work together in order to use them properly.
Many of the examples I could find to reference off of, were created from what I assume are mega-geniuses. I spent the vast majority of my time working backward from convulted and intricate code to try and build a framework that was simple and applicable to my usage case of the OLED. The two figures below are code snippets from this framework that I built referencing ExpressIfs code examples. To be honest, since I cannot test it with a broken OLED, I am not sure if it works or not. </br>
Regardless of the result of my work, the knowledge I gained was time well spent. Through the sea of information, I found many key resources that will be invaluable to both the SPI connection to the OLED and other peripherals. I learned much about utilizing resources provided and got experience attempting to implement them. Ideally, the framework I built will either work or be close to a working state, and I will have then prototyped our display for the project with applicable code to the final design. The next steps I will take is to get a working OLED board and work with TA Fangda to successfully implement the SPI. This could take a wide range of time, depending on my programming. If time, I would like to work on developing code that can do the ship detection. Building a simple test rig with some multiplexers and seeing if I can identify where I place a ship. Also, once the OLED works, I can begin developing the frontend of the user experience and preparing messages such as showing the coordinates as the user types them in, you are playing against xxxx, etc.



<p><img src="Team/progress/img/Code_SPI_1.PNG" width="425" height="700"></img>
<img src="Team/progress/img/Code_SPI_2.PNG" width="425" height="700"></img></p>

	</br>
            <h4>Week 5:</h4>
            <b>Date:</b> 9/24/2021<br>
            <b>Total hours:</b> 15 <br>
            <b>Description of design efforts:</b><br>
	I worked on implementing SPI communication to an OLED board to display relevant game information and worked on conglomerating the display code and the keypad code to work together.
	The main part of the workload was debugging and exploring documentation related to SPI communication and the SOC1602A OLED board. My original framework had several bugs, including accidentally flipping the MOSI and MISO GPIO pins within the microcontroller code. 
	The majority of the debugging was done using an Analog Discovery 2 with digital I/O pins in order to see what signals were coming from the microcontroller and why they weren't displaying to the OLED correctly.
	The MISO/MOSI flip was discovered by looking at the DATA line and seeing that the ESP32 had it constantly set to logic high.
	However, the display still refused to output the correct characters on the OLED and instead showed flickering, random symbols. I could see the correct data using the AD2, with the correct characters in ASCII being outputted.
	I looked deeper into the ESP32 SPI driver and OLED documentation to find the issue was with the 2 command bits that preface a byte. "00" was supposed to preface the command and "10" prefaced data to write. 
	Upon applying these changes and debugging, the SPI communication worked perfectly, as you can see in the below image.

</br>
<img src="Team/progress/img/Wk5_Display2.jpg" width="800" height="400" align="middle" />
</br>
	I also combined the keypad code I developed and the newly created display code to begin making relevant functionality for the battleship game. 
	The combined code allows me to see the physical key press data rather than just monitoring the microcontroller on my computer using printf. As you can see below, the OLED now displays whichever key button was pressed by the user, an important function the project will need to display useful information and entering coordinates as shown below.
	This also required an update to my test rig in order to accommodate both the display and the keypad GPIO pins to connect them in a single microcontroller orientation.
</br>
<img src="Team/progress/img/Wk5_Display1.jpg" width="400" height="600" align="middle" />
</br>
	The result of this week's work is that a viable SPI framework has been developed and I now have a centralized C file that I can prototype off of, rather than split off in multiple projects. The SPI display and keypad scanning work is essentially done, only difference being that the display ordered for the project may have slightly different commands and format, which is easily adjusted. I learned more about SPI and how character displays work and feel confident in being able to adjust the code to the projects specific display. I also learned that sometimes the way to debug is to use external sources, such as the AD2, to physically look at and explore the peripheral outputs.
Next week, I would like to begin developing a prototype boat scanning test rig, now that the team has finalized how we plan to accomplish this. By creating a multiplexed array and checking for shorts, I should be able to develop applicable code for the input of boats by the user.


</br>
            <h4>Week 6:</h4>
            <b>Date:</b> 10/1/2021<br>
            <b>Total hours:</b> 10 <br>
            <b>Description of design efforts:</b><br>
			For Week 6, I worked on prototyping hardware and developing the software for the boat detection. To detect a boat, a 3 to 8 multiplexer selects between 8 other multiplexers,
			which are then receiving the input of 8 "slots" each, for a total of 64 inputs. The microcontroller cycles through the column select lines, and then the row select lines, 
			and looks for a "slot" that has been pulled high. Once a high input logic has been detected, by checking the row and column it occurred on, the microcontroller can identify the 
			position of the placement. As you can see in the test rig below, I only had 6 multiplexers total and enough resistors to pull up 16 inputs, so the microcontroller only cycles 
			through 16 currently, but the concept is the same. I then had the row and column be identified and sent to the display to prove it was identified correctly. If I were to 
			improve the test rig, I would need enough resistors for all of the multiplexers but am confident that the code works as intended through my testing. As a result, the boat
			detection has been prototyped to have real value and should work come implementation time. I learned how the specific boat detection circuit works, as it took me building
			all 5 multiplexers in and debugging to realize I needed pull-up resistors for every input because the mux cannot sink that amount of current in a short. The next steps for me 
			will be acquiring more resistors to hopefully finish the rig, and to work on software to begin identifying where a boat of length would be placed. Essentially, scanning the 
			rows and columns once a short has been detected to find another short, and find each slot that the boat covers. I also want to use a LUT to discard boats that have already been 
			placed.

</br>
<img src="Team/progress/img/Wk6_Test_Rig.jpg" width="400" height="600" align="middle" />
</br>
                      
        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
